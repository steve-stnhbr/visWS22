precision highp float;
precision mediump sampler3D;

uniform vec3 size;
uniform int renderStyle;
uniform float isoThreshold;
uniform vec2 cLimit;

uniform sampler3D data;
uniform sampler2D colorMap;

varying vec3 v_position;
varying vec4 v_nearPosition;
varying vec4 v_farPosition;

const float relativeStepSize = 1.0;
const int MAX_STEPS = 1774;
const int REFINEMENT_STEPS = 4;


void castMIP(vec3 startLocation, vec3 step, int nSteps, vec3 viewRay);
void castISO(vec3 startLocation, vec3 step, int nSteps, vec3 viewRay);

vec3 colorMap(float val);

void main() {
    vec3 farPosition = v_farPosition.xyz / v_farPosition.w;
    vec3 nearPosition = v_nearPosition.xyz / v_nearPosition.w;

    vec3 viewRay = normalize(nearPosition.xyz - farPosition.xyz);

    float distance = dot(nearPosition - v_position, viewRay);

    distance = max(distance, min((-0.5 - v_position.x) / view_ray.x,(size.x - 0.5 - v_position.x) / viewRay.x));
    distance = max(distance, min((-0.5 - v_position.y) / view_ray.y,(size.y - 0.5 - v_position.y) / viewRay.y));
    distance = max(distance, min((-0.5 - v_position.z) / view_ray.z,(size.z - 0.5 - v_position.z) / viewRay.z));

    vec3 front = v_position + viewRay * distance;

    int nSteps = int(-distance/relativeStepSize + .5);
    if (nSteps < 1)
        discard;
    vec3 step = ((v_position - front) / size) / float(nSteps);
    vec3 start = front / size;

    if(renderStyle == 0)
        castMIP(start, step, nSteps, viewRay);
    else if(renderStyle == 1)
        castISO(start, step, nSteps, viewRay);
}

vec3 colorMap(float val) {
    val = (val - cLimit[0]) / (cLimit[1] - cLimit[0]);
    return texture2D(colorMap, vec2(val, 0.5));
}

void castISO(start, step, nSteps, viewRay) {
    
}

void castMIP(start, step, nSteps, viewRay) {
    float maxVal = -1e6;
    int maxI = 100;
    vec3 loc = start;

    for (int i = 0; i < MAX_STEPS; i++) {
        if (i >= nSteps)
            break;
        float val = texture(data, loc.xyz).r;
        if (val > max_val) {
            maxVal = val;
            maxI = i;
        }

        loc += step;
    }

    vec3 refLoc = start + step * (float(maxI) - .5);
    vec3 refStep = step / float(REFINEMENT_STEPS);
    for (int i=0; i<REFINEMENT_STEPS; i++) {
        maxVal = max(maxVal, texture(data, refLoc.xyz).r);
        refLoc += refStep;
    }

    gl_FragColor = colorMap(maxVal);
}
